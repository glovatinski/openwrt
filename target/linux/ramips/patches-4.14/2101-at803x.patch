diff --git a/drivers/net/phy/at803x.c b/drivers/net/phy/at803x.c
index d801c99a74ec..4542a17203ec 100644
--- a/drivers/net/phy/at803x.c
+++ b/drivers/net/phy/at803x.c
@@ -78,6 +78,18 @@
 #define AT803X_PHY_ID_MASK			0xffffffef
 #define AT8032_PHY_ID_MASK			0xffffffff
 
+#define ADVERTISE_FIBER_1000HALF	0x40
+#define ADVERTISE_FIBER_1000FULL	0x20
+
+#define ADVERTISE_PAUSE_FIBER		0x180
+#define ADVERTISE_PAUSE_ASYM_FIBER	0x100
+
+#define LPA_FIBER_1000HALF	0x40
+#define LPA_FIBER_1000FULL	0x20
+
+#define LPA_PAUSE_FIBER		0x180
+#define LPA_PAUSE_ASYM_FIBER	0x100
+
 MODULE_DESCRIPTION("Atheros 803x PHY driver");
 MODULE_AUTHOR("Matus Ujhelyi");
 MODULE_LICENSE("GPL");
@@ -343,35 +355,49 @@ static int at803x_config_init(struct phy_device *phydev)
 	int ret;
 	u32 v;
 
-	if (phydev->drv->phy_id == ATH8031_PHY_ID &&
-		phydev->interface == PHY_INTERFACE_MODE_SGMII)
+	v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
+	printk("at803x_config_init: CHIP: %x\n", v);
+
+	/* reset device */
+	ret = genphy_soft_reset(phydev);
+	if (ret < 0)
+		return ret;
+
+	v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
+	printk("at803x_config_init_2: CHIP: %x\n", v);
+
+	if ( (v & 0xf) == 2 )
 	{
-		v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
+		printk("at803x_config_init: fibre mode\n");
+
 		/* select SGMII/fiber page */
 		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
 						v & ~AT803X_BT_BX_REG_SEL);
 		if (ret)
 			return ret;
+
+		v = phy_read(phydev, MII_BMCR);
+		printk("at803x_config_init: MII_BMCR: %x\n", v);
 		/* enable SGMII autonegotiation */
-		ret = phy_write(phydev, MII_BMCR, AT803X_SGMII_ANEG_EN);
-		if (ret)
-			return ret;
-		/* select copper page */
-		ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG,
-						v | AT803X_BT_BX_REG_SEL);
+		ret = phy_write(phydev, MII_BMCR, v | AT803X_SGMII_ANEG_EN | BIT(9) );
 		if (ret)
 			return ret;
+
+		phydev->supported |= SUPPORTED_FIBRE;
 	}
 
 	ret = genphy_config_init(phydev);
 	if (ret < 0)
 		return ret;
 
+	phydev->advertising |= SUPPORTED_FIBRE;
+
 	if (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID ||
 			phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {
 		ret = at803x_enable_rx_delay(phydev);
 		if (ret < 0)
 			return ret;
+		printk("at803x_config_init: enable_rx_delay\n");
 	}
 
 	if (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID ||
@@ -379,6 +405,7 @@ static int at803x_config_init(struct phy_device *phydev)
 		ret = at803x_enable_tx_delay(phydev);
 		if (ret < 0)
 			return ret;
+		printk("at803x_config_init: enable_tx_delay\n");
 	}
 
 	pdata = dev_get_platdata(&phydev->mdio.dev);
@@ -401,6 +428,18 @@ static int at803x_config_init(struct phy_device *phydev)
 				AT803X_DEBUG_TX_CLK_DLY_EN, 0);
 	}
 
+#if 0 // Loopback test
+	v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
+	printk("at803x_config_init_2: Force loopback test: %x\n", v);
+	v |= BIT(14);
+	ret = phy_write(phydev, MII_BMCR, v);
+
+	v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
+	ret = phy_write(phydev, AT803X_REG_CHIP_CONFIG, v | AT803X_BT_BX_REG_SEL);
+	if (ret)
+		return ret;
+#endif
+
 	return 0;
 }
 
@@ -421,6 +460,7 @@ static int at803x_config_intr(struct phy_device *phydev)
 	value = phy_read(phydev, AT803X_INTR_ENABLE);
 
 	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
+		printk("at803x_config_intr: PHY_INTERRUPT_ENABLED\n");
 		value |= AT803X_INTR_ENABLE_AUTONEG_ERR;
 		value |= AT803X_INTR_ENABLE_SPEED_CHANGED;
 		value |= AT803X_INTR_ENABLE_DUPLEX_CHANGED;
@@ -488,36 +528,166 @@ static void at803x_link_change_notify(struct phy_device *phydev)
 	}
 }
 
-static int at803x_aneg_done(struct phy_device *phydev)
+/**
+ * ethtool_adv_to_fiber_adv_t
+ * @ethadv: the ethtool advertisement settings
+ *
+ * A small helper function that translates ethtool advertisement
+ * settings to phy autonegotiation advertisements for the
+ * MII_ADV register for fiber link.
+ */
+static inline u32 ethtool_adv_to_fiber_adv_t(u32 ethadv)
 {
-	int ccr;
+	u32 result = 0;
 
-	int aneg_done = genphy_aneg_done(phydev);
-	if (aneg_done != BMSR_ANEGCOMPLETE)
-		return aneg_done;
+	if (ethadv & ADVERTISED_1000baseT_Half)
+		result |= ADVERTISE_FIBER_1000HALF;
+	if (ethadv & ADVERTISED_1000baseT_Full)
+		result |= ADVERTISE_FIBER_1000FULL;
 
-	/*
-	 * in SGMII mode, if copper side autoneg is successful,
-	 * also check SGMII side autoneg result
+	if ((ethadv & ADVERTISE_PAUSE_ASYM) && (ethadv & ADVERTISE_PAUSE_CAP))
+		result |= LPA_PAUSE_ASYM_FIBER;
+	else if (ethadv & ADVERTISE_PAUSE_CAP)
+		result |= (ADVERTISE_PAUSE_FIBER
+			   & (~ADVERTISE_PAUSE_ASYM_FIBER));
+
+	return result;
+}
+
+/**
+ * marvell_config_aneg_fiber - restart auto-negotiation or write BMCR
+ * @phydev: target phy_device struct
+ *
+ * Description: If auto-negotiation is enabled, we configure the
+ *   advertising, and then restart auto-negotiation.  If it is not
+ *   enabled, then we write the BMCR. Adapted for fiber link in
+ *   some Marvell's devices.
+ */
+static int marvell_config_aneg_fiber(struct phy_device *phydev)
+{
+	int changed = 0;
+	int err;
+	int adv, oldadv;
+	u32 advertise;
+
+	/* Only allow advertising what this PHY supports */
+	phydev->advertising &= phydev->supported;
+	advertise = phydev->advertising;
+
+	/* Setup fiber advertisement */
+	adv = phy_read(phydev, MII_ADVERTISE);
+	if (adv < 0)
+		return adv;
+
+	oldadv = adv;
+	adv &= ~(ADVERTISE_FIBER_1000HALF | ADVERTISE_FIBER_1000FULL
+		| LPA_PAUSE_FIBER);
+	adv |= ethtool_adv_to_fiber_adv_t(advertise);
+
+	if (adv != oldadv) {
+		err = phy_write(phydev, MII_ADVERTISE, adv);
+		if (err < 0)
+			return err;
+
+		changed = 1;
+	}
+
+	if (changed == 0) {
+		/* Advertisement hasn't changed, but maybe aneg was never on to
+		 * begin with?	Or maybe phy was isolated?
+		 */
+		int ctl = phy_read(phydev, MII_BMCR);
+
+		if (ctl < 0)
+			return ctl;
+
+		if (!(ctl & BMCR_ANENABLE) || (ctl & BMCR_ISOLATE))
+			changed = 1; /* do restart aneg */
+	}
+
+	/* Only restart aneg if we are advertising something different
+	 * than we were before.
 	 */
-	ccr = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
-	if ((ccr & AT803X_MODE_CFG_MASK) != AT803X_MODE_CFG_SGMII)
-		return aneg_done;
+	if (changed > 0)
+		changed = genphy_restart_aneg(phydev);
+
+	return changed;
+}
 
-	/* switch to SGMII/fiber page */
-	phy_write(phydev, AT803X_REG_CHIP_CONFIG, ccr & ~AT803X_BT_BX_REG_SEL);
+static int at803x_config_aneg(struct phy_device *phydev)
+{
+	int v, ret;
+
+	v = phy_read(phydev, AT803X_REG_CHIP_CONFIG);
+	printk("at803x_config_aneg: CHIP: %x\n", v);
+
+	v = phy_read(phydev, MII_BMCR);
+	printk("at803x_config_aneg: MII_BMC: %x\n", v);
+	v &= BMCR_LOOPBACK | BMCR_ISOLATE | BMCR_PDOWN;
+
+	if (phydev->autoneg != AUTONEG_ENABLE) {
+		printk("at803x: genphy_setup_forced! SPEED: %d, DUPLEX: %x\n", phydev->speed, phydev->duplex);
+
+		phydev->pause = 0;
+		phydev->asym_pause = 0;
+
+		if (SPEED_1000 == phydev->speed)
+			v |= BMCR_SPEED1000;
+		else if (SPEED_100 == phydev->speed)
+			v |= BMCR_SPEED100;
+
+		if (DUPLEX_FULL == phydev->duplex)
+			v |= BMCR_FULLDPLX;
+	} else {
+		/* enable SGMII autonegotiation */
+		v |= BIT(12) | BIT(9);
+	}
+	printk("at803x_config_aneg: MII_BMC set: %x\n", v);
+	ret = phy_write(phydev, MII_BMCR, v);
+	if (ret < 0)
+		goto error;
 
-	/* check if the SGMII link is OK. */
-	if (!(phy_read(phydev, AT803X_PSSR) & AT803X_PSSR_MR_AN_COMPLETE)) {
-		pr_warn("803x_aneg_done: SGMII link is not ok\n");
-		aneg_done = 0;
+	if (phydev->autoneg == AUTONEG_ENABLE) {
+		printk("at803x: marvell_config_aneg_fiber!\n");
+		ret = marvell_config_aneg_fiber(phydev);
+		if (ret < 0)
+			goto error;
 	}
-	/* switch back to copper page */
-	phy_write(phydev, AT803X_REG_CHIP_CONFIG, ccr | AT803X_BT_BX_REG_SEL);
 
+	v = phy_read(phydev, MII_BMCR);
+error:
+	printk("at803x_config_aneg: MII_BMC: %x\n", v);
+	return ret;
+}
+
+static int at803x_aneg_done(struct phy_device *phydev)
+{
+	int ccr, v;
+	int aneg_done = genphy_aneg_done(phydev);
+
+	/* Read PHY-Specific Status */
+	ccr = phy_read(phydev, AT803X_PSSR);
+	printk("803x_aneg_done: AT803X_PSSR: %x, %x\n", ccr, aneg_done);
+
+	/* SGMII serdes enable for fiber */
+	if ((phy_read(phydev, AT803X_REG_CHIP_CONFIG) & 0xF) == 2) {
+		pr_warn("803x_aneg_done: Fiber mode\n");
+
+		ccr = phy_read(phydev, AT803X_PSSR);
+		/* check if the SGMII link is OK. */
+		if (!(ccr & AT803X_PSSR_MR_AN_COMPLETE)) {
+			pr_warn("803x_aneg_done: SGMII link is not ok\n");
+			aneg_done = 0;
+		}
+	}
+end:
+	v = phy_read(phydev, MII_BMCR);
+	printk("at803x_config_aneg: MII_BMC: %x\n", v);
+	pr_warn("803x_aneg_done: %x, %x\n", aneg_done, v);
 	return aneg_done;
 }
 
+
 static struct phy_driver at803x_driver[] = {
 {
 	/* ATHEROS 8035 */
@@ -567,9 +737,9 @@ static struct phy_driver at803x_driver[] = {
 	.resume			= at803x_resume,
 	.features		= PHY_GBIT_FEATURES | SUPPORTED_FIBRE,
 	.flags			= PHY_HAS_INTERRUPT,
-	.config_aneg		= genphy_config_aneg,
 	.read_status		= genphy_read_status,
 	.aneg_done		= at803x_aneg_done,
+	.config_aneg		= at803x_config_aneg,
 	.ack_interrupt		= at803x_ack_interrupt,
 	.config_intr		= at803x_config_intr,
 	.set_loopback		= genphy_loopback,
