diff --git a/drivers/net/dsa/mt7530.c b/drivers/net/dsa/mt7530.c
index dc48f01674ab..fd3069ab4340 100644
--- a/drivers/net/dsa/mt7530.c
+++ b/drivers/net/dsa/mt7530.c
@@ -1005,14 +1005,21 @@ mt7530_setup(struct dsa_switch *ds)
 	val &= ~MHWTRAP_P5_DIS & ~MHWTRAP_P6_DIS & ~MHWTRAP_PHY_ACCESS;
 	val |= MHWTRAP_MANUAL;
 
+#if 0
 	if (!dsa_is_cpu_port(ds, 5)) {
 		val |= MHWTRAP_P5_DIS;
 		val |= MHWTRAP_P5_MAC_SEL;
 		val |= MHWTRAP_P5_RGMII_MODE;
 	};
+#endif
+
+	// Enable P5
+	val |= MHWTRAP_P5_MAC_SEL;
+	val |= MHWTRAP_P5_RGMII_MODE;
 
 	mt7530_write(priv, MT7530_MHWTRAP, val);
 
+#if 0
 	if (!dsa_is_cpu_port(ds, 5)) {
 		dev_info(priv->dev, "P5 disabled.\n");
 		/* (P5, link OFF) */
@@ -1030,6 +1037,25 @@ mt7530_setup(struct dsa_switch *ds)
 		val = CSR_RGMII_EDGE_ALIGN | CSR_RGMII_RXC_0DEG_CFG(2);
 		mt7530_write(priv, MT7530_P5RGMIIRXCR, val);
 	}
+#else
+
+	dev_info(priv->dev, "P5 enabled.\n");
+
+	/* (P5, link OFF) */
+	mt7530_write(priv, MT7530_PMCR_P(5), PMCR_COMMON_LINK);
+
+	/* P5 RGMII TX Clock Control, delay 0 */
+	mt7530_write(priv, MT7530_P5RGMIITXCR, CSR_RGMII_TXC_CFG(0x10));
+
+	/* reduce P5 RGMII Tx driving, 8mA*/
+	val = P5_IO_CLK_DRV(1);
+	val |= P5_IO_DATA_DRV(1);
+	mt7530_write(priv, MT7530_IO_DRV_CR, val);
+
+	/* P5 RGMII RX Clock Control: delay setting for 1000M */
+	val = CSR_RGMII_EDGE_ALIGN | CSR_RGMII_RXC_0DEG_CFG(2);
+	mt7530_write(priv, MT7530_P5RGMIIRXCR, val);
+#endif
 
 	/* Enable and reset MIB counters */
 	mt7530_mib_reset(ds);
